(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{390:function(t,a,s){"use strict";s.r(a);var n=s(1),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"分页的设计过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分页的设计过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 分页的设计过程")]),t._v(" "),s("h2",{attrs:{id:"面向接口编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向接口编程","aria-hidden":"true"}},[t._v("#")]),t._v(" 面向接口编程")]),t._v(" "),s("ul",[s("li",[t._v("思考需求：想想自己平时如何使用分页器，用户一般有哪些需求")]),t._v(" "),s("li",[t._v("设计接口：根据需求分析出分页需要有哪些参数，样式需要有哪些特点")]),t._v(" "),s("li",[t._v("参考经典UI框架的设计方式")])]),t._v(" "),s("p",[t._v("结合上述3点，分析出一个分页器的接口和样式")]),t._v(" "),s("ul",[s("li",[t._v("接口\n"),s("ul",[s("li",[t._v("1.接受「total-page」: 总共多少页")]),t._v(" "),s("li",[t._v("2.接受「current-page」: 当前是第几页")]),t._v(" "),s("li",[t._v("3.接受 change 事件")]),t._v(" "),s("li",[t._v("4.接受 「hide-if-one-page」只有1页时，是否自动隐藏分页器")]),t._v(" "),s("li",[t._v("5.接受 next/prev 按钮")])])]),t._v(" "),s("li",[t._v("样式的显示逻辑\n"),s("ul",[s("li",[t._v("1.观察得出一般的分页，必须显示的的页码。第1页、最后1页、当前页、当前页-1、当前页-2、当前页+1、当前页+2，一共7页")]),t._v(" "),s("li",[t._v("2.如果总页数少于7页，就全都显示，多于7页的部分用...表示")]),t._v(" "),s("li",[t._v("3.分页器的样式不能做成圆圈，因为页码位数可能无限增加的原因，可以考虑用方形、矩形或者不带边框。")])])])]),t._v(" "),s("h2",{attrs:{id:"设计组件api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计组件api","aria-hidden":"true"}},[t._v("#")]),t._v(" 设计组件API")]),t._v(" "),s("p",[t._v("我觉得其实这一步，就是想象你的用户会如何调用组件")]),t._v(" "),s("p",[t._v("这里我觉得page-size可以考虑不要，因为一页展示多少数据，开发人员算就行了，我分页不需要知道那么多。")]),t._v(" "),s("div",{staticClass:"language-vue extra-class"},[s("pre",{pre:!0,attrs:{class:"language-vue"}},[s("code",[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("l-pager")]),t._v(" "),s("span",{attrs:{class:"token attr-name"}},[t._v(":total-page")]),s("span",{attrs:{class:"token attr-value"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{attrs:{class:"token punctuation"}},[t._v('"')]),t._v("20"),s("span",{attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{attrs:{class:"token attr-name"}},[t._v(":current-page.sync")]),s("span",{attrs:{class:"token attr-value"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{attrs:{class:"token punctuation"}},[t._v('"')]),t._v("currentPage"),s("span",{attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{attrs:{class:"token attr-name"}},[t._v("@currentChange")]),s("span",{attrs:{class:"token attr-value"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{attrs:{class:"token punctuation"}},[t._v('"')]),t._v("onCurrentChange"),s("span",{attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token tag"}},[s("span",{attrs:{class:"token punctuation"}},[t._v("</")]),t._v("l-pager")]),s("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("h2",{attrs:{id:"实现分页组件的注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现分页组件的注意点","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现分页组件的注意点")]),t._v(" "),s("ul",[s("li",[t._v("1.需要先思考清楚分页页码的显示逻辑，并做好渲染判断。")])]),t._v(" "),s("p",[t._v("比如我这里的渲染规则就是，必须显示的的页码。第1页、最后1页、当前页、当前页-1、当前页-2、当前页+1、当前页+2，一共7页，")]),t._v(" "),s("p",[t._v("其他页码用...显示,需要做好边界条件判断")]),t._v(" "),s("ul",[s("li",[t._v("2.利用.sync单项数据流，让逻辑变得更加清晰。")])]),t._v(" "),s("p",[t._v("当用户点击「页码」或者「上一页」，组件内部做的事情十分清晰，就是通知父组件，我变了，父组件则根据当前页码重新渲染页面。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("   "),s("span",{attrs:{class:"token function"}},[t._v("onClickPage")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("page"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("page "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("||")]),t._v(" page "),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("totalPage"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("$emit")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token string"}},[t._v('"update:currentPage"')]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" page"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("$emit")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token string"}},[t._v('"currentChange"')]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" page"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{attrs:{class:"token comment"}},[t._v("// 重新渲染page组件,渲染哪些页码应该是根据当前页码来决定的")]),t._v("\n      "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("reRender")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("page"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),s("p",[t._v("当然我们还可以使用计算属性来计算pages，而不是在mounted和onClickPage时调用reRender()")]),t._v(" "),s("ul",[s("li",[t._v("这样初次页面渲染时，pages会将render watcher作为依赖收集，同时读取计算属性pages，还会触发内部totalPage等属性的getter，于是这些属性把computed watcher作为依赖收集")]),t._v(" "),s("li",[t._v("将来当totalPage或者currentPage发生变化时，compted watcher的update就会被触发，如果新旧值发生变化，就computed watcher会调用notify()，通知render watcher调用自己的update方法更新视图")])]),t._v(" "),s("p",[t._v("这样可以很好的利用计算属性惰性求值")]),t._v(" "),s("h2",{attrs:{id:"tdd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tdd","aria-hidden":"true"}},[t._v("#")]),t._v(" TDD")]),t._v(" "),s("p",[t._v("分页组件的单元测试，还是常规思路")]),t._v(" "),s("ul",[s("li",[t._v("构造一个分页组件，传递propData，测试样式和数据是否正常")]),t._v(" "),s("li",[t._v("模仿点击事件，测试是否可以触发change事件，并且得到当前页码")])])])}],!1,null,null,null);e.options.__file="pager.md";a.default=e.exports}}]);